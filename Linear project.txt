PART 1

import sympy as sp
import numpy as np

def read_matrix():
    r = int(input("Enter number of rows: "))
    c = int(input("Enter number of columns: "))
    print("Enter matrix row by row:")
    matrix = []
    for _ in range(r):
        row = list(map(float, input().split()))
        matrix.append(row)
    return sp.Matrix(matrix)

def menu():
    print("\n=== Linear Algebra Menu ===")
    print("1. Row Echelon Form (REF)")
    print("2. Reduced Row Echelon Form (RREF)")
    print("3. Matrix addition")
    print("4. Matrix subtraction")
    print("5. Scalar multiplication")
    print("6. Matrix multiplication")
    print("7. Determinant")
    print("8. Cramer's rule")
    print("9. Linear independence check")
    print("10. Basis and dimension")
    print("11. Eigenvalues and eigenvectors")
    print("12. Diagonalization")
    print("0. Exit")

def main():
    A = read_matrix()

    while True:
        menu()
        choice = int(input("Choose an option: "))

        if choice == 1:
            print("REF:")
            print(A.echelon_form())

        elif choice == 2:
            print("RREF:")
            print(A.rref()[0])

        elif choice == 3:
            print("Enter second matrix:")
            B = read_matrix()
            print("A + B =")
            print(A + B)

        elif choice == 4:
            print("Enter second matrix:")
            B = read_matrix()
            print("A - B =")
            print(A - B)

        elif choice == 5:
            k = float(input("Enter scalar: "))
            print(k * A)

        elif choice == 6:
            print("Enter second matrix:")
            B = read_matrix()
            print("A * B =")
            print(A * B)

        elif choice == 7:
            if A.rows == A.cols:
                print("det(A) =", A.det())
            else:
                print("Matrix must be square!")

        elif choice == 8:  # Cramer's rule
            print("Enter vector b:")
            b = []
            for i in range(A.rows):
                b.append(float(input(f"b[{i}] = ")))
            b = sp.Matrix(b)
            print("Solution by Cramer's rule:")
            print(A.solve(b))

        elif choice == 9:
            print("Checking linear independence...")
            print("Rank:", A.rank())
            if A.rank() == A.cols:
                print("Columns are linearly independent")
            else:
                print("Columns are linearly dependent")

        elif choice == 10:
            print("Row space basis:", A.rowspace())
            print("Column space basis:", A.columnspace())
            print("Dimension:", A.rank())

        elif choice == 11:
            print("Eigenvalues:", A.eigenvals())
            print("Eigenvectors:", A.eigenvects())

        elif choice == 12:
            print("Diagonalization:")
            try:
                P, D = A.diagonalize()
                print("P =")
                print(P)
                print("D =")
                print(D)
            except:
                print("Matrix is NOT diagonalizable")

        elif choice == 0:
            break

        else:
            print("Invalid choice")

if __name__ == "__main__":
    main()


PARE 2

import sympy as sp
import sys
from sympy import Function, symbols

def standardize_and_solve(equation_str):
    x = sp.symbols('x')
    y = sp.Function('y')

    # --- FIX: Replace derivative styles before parsing ---
    eq_str = equation_str

    # Support y'(x), y''(x), y'''(x)
    eq_str = eq_str.replace("y'''(x)", "Derivative(y(x),x,3)")
    eq_str = eq_str.replace("y''(x)",  "Derivative(y(x),x,2)")
    eq_str = eq_str.replace("y'(x)",   "Derivative(y(x),x)")

    # Support y', y'', y''' without (x)
    eq_str = eq_str.replace("y'''", "Derivative(y(x),x,3)")
    eq_str = eq_str.replace("y''",  "Derivative(y(x),x,2)")
    eq_str = eq_str.replace("y'",   "Derivative(y(x),x)")

    # Support dy/dx
    eq_str = eq_str.replace("dy/dx", "Derivative(y(x),x)")

    try:
        # If the user wrote an '='
        if '=' in eq_str:
            left_s, right_s = eq_str.split('=', 1)
            left = sp.sympify(left_s, locals={'y': y, 'x': x})
            right = sp.sympify(right_s, locals={'y': y, 'x': x})
            eq = sp.Eq(left, right)
        else:
            expr = sp.sympify(eq_str, locals={'y': y, 'x': x})
            eq = sp.Eq(expr, 0)
    except Exception as e:
        print("Error: Can't parse equation:", e)
        sys.exit(1)

    sol = sp.dsolve(eq)
    return eq, sol

def main():
    print("Enter your ODE (example: y'(x) + 2*y(x) - sin(x))")
    equation_str = input("ODE = ")

    eq, sol = standardize_and_solve(equation_str)

    print("\nInterpreted equation:")
    print(eq)

    print("\nSolution:")
    print(sol)

if __name__ == "__main__":
    main()
